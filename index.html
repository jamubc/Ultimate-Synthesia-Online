<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
        <title>Ultimate Synthesia Online</title>
        <link href="stylemain.css" rel="stylesheet"/>
    </head>
    <body>
        <div class="container">
            <h1>Ultimate Synthesia Online</h1>

            <div class="looper-toggle-bar">
                <button id="toggleLooperButton" class="std-button">Show Looper</button>
            </div>
            <div class="launchpad-looper-container" id="launchpadLooperContainer">
                <!-- Loop slots will be generated by JavaScript -->
            </div>

            <div class="controls">
                <div class="control-group" id="osc1-group">
                    <div class="control-title">Oscillator 1</div>
                    <label> Waveform <select id="waveformOsc1"> <option value="sine">Sine</option> <option value="square">Square</option> <option value="sawtooth" selected>Sawtooth</option> <option value="triangle">Triangle</option> <option value="pulse">Pulse</option> </select> </label>
                    <label> Octave (Base) <select id="octaveOsc1"> <option value="2">2</option> <option value="3">3</option> <option value="4" selected>4</option> <option value="5">5</option> <option value="6">6</option> </select> </label>
                    <label>Detune (cents) <input type="range" id="detuneOsc1" min="-100" max="100" step="1" value="0" class="horizontal-slider" /></label>
                    <label>Osc 1 Level <input type="range" id="levelOsc1" min="0" max="1" step="0.01" value="0.7" class="horizontal-slider" /></label>
                </div>

                <div class="control-group" id="osc2-group">
                    <div class="control-title">Oscillator 2 <label class="switch"> <input type="checkbox" id="enableOsc2" checked> <span class="slider-switch"></span> </label> </div>
                    <div id="osc2-controls-wrapper">
                        <label> Osc 2 Waveform <select id="waveformOsc2"> <option value="sine">Sine</option> <option value="square">Square</option> <option value="sawtooth" selected>Sawtooth</option> <option value="triangle">Triangle</option> <option value="pulse">Pulse</option> </select> </label>
                        <label> Osc 2 Octave Offset <select id="octaveOsc2"> <option value="-2">-2</option> <option value="-1">-1</option> <option value="0" selected>0</option> <option value="1">+1</option> <option value="2">+2</option> </select> </label>
                        <label>Osc 2 Fine Tune (cents) <input type="range" id="fineTuneOsc2" min="-100" max="100" step="1" value="0" class="horizontal-slider" /></label>
                        <label>Osc 2 Start Delay (ms) <input type="range" id="delayOsc2" min="0" max="50" step="0.1" value="0" class="horizontal-slider" /></label>
                        <label>Osc 2 Level <input type="range" id="levelOsc2" min="0" max="1" step="0.01" value="0.7" class="horizontal-slider" /></label>
                    </div>
                </div>

                <div class="control-group" id="sub-noise-group">
                     <div class="control-title">Sub Oscillator <label class="switch"> <input type="checkbox" id="enableSub" checked> <span class="slider-switch"></span> </label> </div>
                    <div id="sub-osc-controls">
                        <label> Sub Waveform <select id="waveformSub"> <option value="sine">Sine</option> <option value="square" selected>Square</option> <option value="triangle">Triangle</option> </select> </label>
                        <label> Sub Octave <select id="octaveSub"> <option value="-1">-1 Oct</option> <option value="-2" selected>-2 Oct</option> </select> </label>
                        <label>Sub Level <input type="range" id="levelSub" min="0" max="1" step="0.01" value="0.5" class="horizontal-slider" /></label>
                    </div>
                    <hr style="border-color: var(--border-color); margin: 15px 0;" />
                     <div class="control-title">Noise <label class="switch"> <input type="checkbox" id="enableNoise" > <span class="slider-switch"></span> </label> </div>
                    <div id="noise-controls" style="display: none;">
                        <label> Noise Type <select id="noiseType"> <option value="white">White</option> <option value="pink">Pink (Approx)</option> </select> </label>
                        <label>Noise Level <input type="range" id="levelNoise" min="0" max="1" step="0.01" value="0" class="horizontal-slider" /></label>
                    </div>
                    <hr style="border-color: var(--border-color); margin: 15px 0;" />
                    <div class="control-title">Common Pulse/Slop</div>
                    <label id="pulseWidthLabel" class="hidden-control">Pulse Width <input type="range" id="pulseWidth" min="0.01" max="0.99" step="0.01" value="0.5" class="horizontal-slider" /></label>
                    <label>Oscillator Slop <input type="range" id="oscSlop" min="0" max="0.1" step="0.001" value="0.005" class="horizontal-slider" /></label>
                </div>

                <div class="control-group" id="envelope-group">
                    <div class="control-title">Envelope (ADSR) <label class="switch"> <input type="checkbox" id="enableAdsr" checked> <span class="slider-switch"></span> </label> </div>
                    <div id="adsr-controls">
                        <label>Attack (s) <input type="range" id="attack" min="0.001" max="2" step="0.001" value="0.05" class="horizontal-slider" /></label>
                        <label>Decay (s) <input type="range" id="decay" min="0.001" max="2" step="0.001" value="0.1" class="horizontal-slider" /></label>
                        <label>Sustain (level) <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.6" class="horizontal-slider" /></label>
                        <label>Release (s) <input type="range" id="release" min="0.001" max="5" step="0.001" value="0.5" class="horizontal-slider" /></label>
                    </div>
                </div>
                
                <div class="control-group" id="metronome-tempo-group">
                    <div class="control-title">Metronome & Tempo</div>
                    <div class="metronome-controls">
                        <label style="margin-bottom: 5px;"> <input type="checkbox" id="metronomeToggle" /> Metronome <span class="led" id="metronomeLed" title="Metronome Tick"></span> </label>
                        <div class="bpm-adjust-buttons"> <button id="bpmDecrement" class="std-button bpm-button">-</button> <span id="bpmDisplay">120</span> <button id="bpmIncrement" class="std-button bpm-button">+</button> </div>
                        <button id="tapTempoButton" class="std-button">Tap BPM</button>
                    </div>
                </div>

                <div class="control-group" id="filter-group">
                    <div class="control-title">Filter <label class="switch"> <input type="checkbox" id="enableFilter" checked> <span class="slider-switch"></span> </label> </div>
                    <div id="filter-controls">
                        <label> Type <select id="filterType"> <option value="lowpass" selected>Lowpass</option> <option value="highpass">Highpass</option> <option value="bandpass">Bandpass</option> <option value="notch">Notch</option> <option value="allpass">Allpass (Bypass)</option> </select> </label>
                        <label>Cutoff (Hz) <input type="range" id="filterCutoff" min="20" max="20000" step="1" value="5000" data-log="true" class="horizontal-slider" /></label>
                        <label>Resonance (Q) <input type="range" id="filterResonance" min="0.001" max="30" step="0.01" value="2" class="horizontal-slider" /></label>
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-title">Master & Settings</div>
                    <label> Keyboard Octaves <select id="numOctavesSelect"> <option value="1">1 Octave</option> <option value="2" selected>2 Octaves</option> <option value="3">3 Octaves</option> <option value="4">4 Octaves</option> </select> </label>
                    <label>Volume <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.7" class="horizontal-slider" /></label>
                    <label> Visualizer Source <select id="visualizerSourceSelect"> <option value="master" selected>Master Output</option> <option value="osc1">Oscillator 1 Sum</option> <option value="osc2">Oscillator 2 Sum</option> </select> </label>
                    <label style="margin-top: calc(15px * var(--font-scale-factor));"> UI Theme <select id="uiTheme"> <option value="midnight-drive">Midnight Drive</option> <option value="solarized-dark">Solarized Dark</option> <option value="crimson-peak">Crimson Peak</option> <option value="cyber-glow">Cyber Glow</option> <option value="forest-calm">Forest Calm</option> <option value="ocean-depth">Ocean Depth</option> <option value="autumn-warmth">Autumn Warmth</option> <option value="lavender-haze">Lavender Haze</option> <option value="desert-sunset">Desert Sunset</option> <option value="steampunk-gears">Steampunk Gears</option> <option value="vintage-library">Vintage Library</option> <option value="monochrome-noir">Monochrome Noir</option> <option value="pastel-dream">Pastel Dream</option> </select> </label>
                    <label>UI Scale (%) <input type="range" id="uiScale" min="75" max="150" step="5" value="100" class="horizontal-slider" /></label>
                    <label style="margin-top: calc(15px * var(--font-scale-factor));"><input type="checkbox" id="synthesiaToggle" /> Enable Falling Notes</label>
                    <div style="margin-top: calc(20px * var(--font-scale-factor)); text-align: center;"><span class="led" id="led1"></span><span class="led" id="led2"></span><span class="led" id="led3"></span></div>
                </div>
            </div>

            <div class="visualizer"> <canvas id="visualizerCanvas"></canvas> <div class="visualizer-time-axis"><span>0ms</span><span>~23ms</span><span>~46ms</span></div> </div>
            <div class="keyboard" id="keyboard"></div>
            <div class="synthesia-container" id="synthesiaContainer"> <div class="synthesia-hit-line"></div> </div>
        </div>
        <button id="stopAllSoundsButton" class="std-button" title="Stop All Sounds (Panic Button)">PANIC</button>

        <script>
            const AudioContextGlobal = window.AudioContext || window.webkitAudioContext;
            let audioContext;
            let masterGain, filterNode, filterBypassGain, masterLimiter, analyser, analyserOsc1, analyserOsc2;
            let summingGainOsc1, summingGainOsc2;
            let visualizerCanvas, visualizerContext;

            const activeSoundUnits = {}; // For live played notes
            const activeComputerKeys = new Set();
            const activeTouches = new Map();
            let isMouseDraggingOnKeyboard = false;
            let currentDraggedKeyElement = null;

            const keyMapping = {'a':0,'w':1,'s':2,'e':3,'d':4,'f':5,'t':6,'g':7,'y':8,'h':9,'u':10,'j':11,'k':12,'o':13,'l':14,'p':15,';':16,'\'':17};
            const keyReverseLookup = {}; Object.keys(keyMapping).forEach(k => keyReverseLookup[keyMapping[k]] = k);

            let waveformOsc1Select, octaveOsc1Select, detuneOsc1Input, levelOsc1Input,
                enableOsc2Toggle, waveformOsc2Select, octaveOsc2Select, fineTuneOsc2Input, delayOsc2Input, levelOsc2Input, osc2ControlsWrapper,
                enableSubToggle, waveformSubSelect, octaveSubSelect, levelSubInput, subOscControls,
                enableNoiseToggle, noiseTypeSelect, levelNoiseInput, noiseControls,
                pulseWidthLabel, pulseWidthInput, oscSlopInput,
                enableAdsrToggle, attackInput, decayInput, sustainInput, releaseInput, adsrControls,
                enableFilterToggle, filterTypeSelect, filterCutoffInput, filterResonanceInput, filterControlsElement,
                masterVolumeInput, numOctavesSelect, visualizerSourceSelect,
                keyboardContainer, uiThemeSelect, uiScaleInput,
                synthesiaToggle, synthesiaContainer, stopAllSoundsButton,
                toggleLooperButton; // Added for looper toggle
            let whiteNoiseBuffer;

            const keysPattern = [{type:'white',note:'C'},{type:'black',note:'C#'},{type:'white',note:'D'},{type:'black',note:'D#'},{type:'white',note:'E'},{type:'white',note:'F'},{type:'black',note:'F#'},{type:'white',note:'G'},{type:'black',note:'G#'},{type:'white',note:'A'},{type:'black',note:'A#'},{type:'white',note:'B'}];
            const midiNoteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
            const WHITE_KEYS_PER_OCTAVE = 7;
            const themes = { "midnight-drive": {}, "solarized-dark": {"--bg-color":"#002b36","--primary-surface-color":"#073642","--secondary-surface-color":"#586e75","--accent-color":"#2aa198","--accent-color-darker":"#22847B","--text-color":"#93a1a1","--text-muted-color":"#839496","--border-color":"#657b83","--key-white-bg":"#eee8d5","--key-black-bg":"#001f27","--key-label-white-color":"#586e75","--key-label-black-color":"#93a1a1","--key-label-active-color":"#002b36"}, "crimson-peak": {"--bg-color":"#2C0A1E","--primary-surface-color":"#4B0D30","--secondary-surface-color":"#6A1F44","--accent-color":"#FF4081","--accent-color-darker":"#F50057","--text-color":"#F8BBD0","--text-muted-color":"#E1A0B5","--border-color":"#88365F","--key-white-bg":"#FCE4EC","--key-black-bg":"#3E0620","--key-label-white-color":"#6A1F44","--key-label-black-color":"#F8BBD0","--key-label-active-color":"#2C0A1E"}, "cyber-glow": {"--bg-color":"#0D0221","--primary-surface-color":"#24134A","--secondary-surface-color":"#3C2A7D","--accent-color":"#F900BF","--accent-color-darker":"#C70099","--text-color":"#A075FF","--text-muted-color":"#7C51D7","--border-color":"#5A3FB4","--key-white-bg":"#E6DFFF","--key-black-bg":"#1A0F33","--key-label-white-color":"#3C2A7D","--key-label-black-color":"#A075FF","--key-label-active-color":"#0D0221"}, "forest-calm": {"--bg-color":"#2A3D2F","--primary-surface-color":"#3F5745","--secondary-surface-color":"#5B7565","--accent-color":"#8AB088","--accent-color-darker":"#6E8C6D","--text-color":"#D8E0D9","--text-muted-color":"#B8C0B9","--border-color":"#7A8E7E","--key-white-bg":"#F0F2EF","--key-black-bg":"#1E2A22","--key-label-white-color":"#5B7565","--key-label-black-color":"#D8E0D9","--key-label-active-color":"#2A3D2F"}, "ocean-depth": {"--bg-color":"#0F1E3D","--primary-surface-color":"#1A325A","--secondary-surface-color":"#2C4A7D","--accent-color":"#36A2EB","--accent-color-darker":"#277FBF","--text-color":"#AEC9E8","--text-muted-color":"#8DA9C7","--border-color":"#4E6A94","--key-white-bg":"#E0E8F5","--key-black-bg":"#0A142A","--key-label-white-color":"#2C4A7D","--key-label-black-color":"#AEC9E8","--key-label-active-color":"#0F1E3D"}, "autumn-warmth": {"--bg-color":"#4A2A1E","--primary-surface-color":"#6E4532","--secondary-surface-color":"#8C5A40","--accent-color":"#E87A3F","--accent-color-darker":"#BF602F","--text-color":"#F0D9C9","--text-muted-color":"#D9C0AE","--border-color":"#A87A5F","--key-white-bg":"#FAF0E6","--key-black-bg":"#361E15","--key-label-white-color":"#8C5A40","--key-label-black-color":"#F0D9C9","--key-label-active-color":"#4A2A1E"}, "lavender-haze": {"--bg-color":"#4A4057","--primary-surface-color":"#675A7B","--secondary-surface-color":"#807399","--accent-color":"#B298DC","--accent-color-darker":"#967BBC","--text-color":"#E6E0F0","--text-muted-color":"#C9C0D9","--border-color":"#998FAA","--key-white-bg":"#F5F0FA","--key-black-bg":"#352F3F","--key-label-white-color":"#807399","--key-label-black-color":"#E6E0F0","--key-label-active-color":"#4A4057"}, "desert-sunset": {"--bg-color":"#3D1B0B","--primary-surface-color":"#5A2A10","--secondary-surface-color":"#7C3E17","--accent-color":"#FF7B2E","--accent-color-darker":"#D9601B","--text-color":"#FADCB9","--text-muted-color":"#EBC9A0","--border-color":"#995424","--key-white-bg":"#FFF5E8","--key-black-bg":"#2A1207","--key-label-white-color":"#7C3E17","--key-label-black-color":"#FADCB9","--key-label-active-color":"#3D1B0B"}, "steampunk-gears": {"--bg-color":"#4A3B31","--primary-surface-color":"#6B5A4F","--secondary-surface-color":"#8C7C6E","--accent-color":"#D4A373","--accent-color-darker":"#B08968","--text-color":"#E0D6CC","--text-muted-color":"#C1B6AB","--border-color":"#A8998B","--key-white-bg":"#FDF6F0","--key-black-bg":"#382C25","--key-label-white-color":"#8C7C6E","--key-label-black-color":"#E0D6CC","--key-label-active-color":"#4A3B31"}, "vintage-library": {"--bg-color":"#3D352A","--primary-surface-color":"#5A5043","--secondary-surface-color":"#7C7263","--accent-color":"#A89A85","--accent-color-darker":"#8F826F","--text-color":"#DED8CF","--text-muted-color":"#BEB6AB","--border-color":"#968B7A","--key-white-bg":"#F7F4EF","--key-black-bg":"#2A251E","--key-label-white-color":"#7C7263","--key-label-black-color":"#DED8CF","--key-label-active-color":"#3D352A"}, "monochrome-noir": {"--bg-color":"#1C1C1C","--primary-surface-color":"#2B2B2B","--secondary-surface-color":"#3A3A3A","--accent-color":"#7F7F7F","--accent-color-darker":"#606060","--text-color":"#D4D4D4","--text-muted-color":"#A8A8A8","--border-color":"#505050","--key-white-bg":"#E8E8E8","--key-black-bg":"#121212","--key-label-white-color":"#3A3A3A","--key-label-black-color":"#D4D4D4","--key-label-active-color":"#1C1C1C"}, "pastel-dream": {"--bg-color":"#F0E6FF","--primary-surface-color":"#E0D1F5","--secondary-surface-color":"#D1BCED","--accent-color":"#A78BFA","--accent-color-darker":"#8A6FD7","--text-color":"#5C4B7C","--text-muted-color":"#7E6A9F","--border-color":"#BDAAE0","--key-white-bg":"#FFFFFF","--key-black-bg":"#DCC9F7","--key-label-white-color":"#5C4B7C","--key-label-black-color":"#4A3A66","--key-label-active-color":"#F0E6FF"} };
            function applyTheme(themeName) { const t=themes[themeName],rS=document.documentElement.style;for(const [k,v] of Object.entries(t)){rS.setProperty(k,v);}if(themeName==="midnight-drive"){Object.keys(themes["solarized-dark"]).forEach(k=>rS.removeProperty(k));}localStorage.setItem('synthTheme',themeName);}
            function applyUIScale(scalePercent) { document.documentElement.style.setProperty('--font-scale-factor',scalePercent/100);localStorage.setItem('synthUIScale',scalePercent);resizeCanvas();}

            let activeVisualNoteElements = [];
            const FALL_SPEED_PIXELS_PER_SECOND = 100; 
            const NOTE_TAIL_DURATION_MS_VISUAL = 2500; 
            const MIN_FALLING_NOTE_HEIGHT = 10; 
            const BURST_ANIMATION_DURATION = 300; // ms, should match CSS

            // Looper state
            const NUM_LOOP_SLOTS = 4;
            let loopSlotsData = [];
            let currentArmedSlotId = -1; 
            let looperQuantizationTimeout = null;
            let launchpadLooperContainer;


            let metronomeEnabled = false, currentBPM = 120, metronomeIntervalId = null, metronomeClickBuffer, metronomeToggle, bpmDisplay, bpmIncrement, bpmDecrement, tapTempoButton, metronomeLed;
            const MIN_BPM = 30, MAX_BPM = 300, tapTempoTimes = []; let tapTempoLastTap; const MAX_TAP_INTERVAL = 3000;
            let sustainPedalActive = false, notesSustained = new Set();


            function createNoiseBuffers() { if (!audioContext) return; const bS = audioContext.sampleRate * 2; whiteNoiseBuffer = audioContext.createBuffer(1, bS, audioContext.sampleRate); const o = whiteNoiseBuffer.getChannelData(0); for (let i=0; i<bS; i++) o[i] = Math.random()*2-1;}
            function createMetronomeClickBuffer() { if (!audioContext) return; const d=0.025, sR=audioContext.sampleRate, fC=Math.floor(sR*d); metronomeClickBuffer=audioContext.createBuffer(1,fC,sR); const data=metronomeClickBuffer.getChannelData(0); data[0]=0.8; data[1]=-0.8; for(let i=2;i<fC;i++)data[i]=(Math.random()*0.2-0.1)*(1-i/fC);}

            function initAudio() {
                if(audioContext) return;
                audioContext = new AudioContextGlobal();
                createNoiseBuffers(); createMetronomeClickBuffer();

                masterGain = audioContext.createGain();
                masterGain.gain.value = parseFloat(masterVolumeInput.value);

                summingGainOsc1 = audioContext.createGain();
                summingGainOsc2 = audioContext.createGain();

                filterNode = audioContext.createBiquadFilter();
                filterBypassGain = audioContext.createGain(); 
                
                masterLimiter = audioContext.createDynamicsCompressor();
                masterLimiter.threshold.setValueAtTime(-3, audioContext.currentTime); 
                masterLimiter.knee.setValueAtTime(0, audioContext.currentTime);      
                masterLimiter.ratio.setValueAtTime(20, audioContext.currentTime);    
                masterLimiter.attack.setValueAtTime(0.003, audioContext.currentTime); 
                masterLimiter.release.setValueAtTime(0.1, audioContext.currentTime); 

                filterNode.connect(masterGain);
                filterBypassGain.connect(masterGain);
                masterGain.connect(masterLimiter);


                analyser = audioContext.createAnalyser(); analyser.fftSize = 2048;
                analyserOsc1 = audioContext.createAnalyser(); analyserOsc1.fftSize = 2048;
                analyserOsc2 = audioContext.createAnalyser(); analyserOsc2.fftSize = 2048;

                summingGainOsc1.connect(analyserOsc1);
                summingGainOsc2.connect(analyserOsc2);
                
                masterLimiter.connect(analyser); 
                analyser.connect(audioContext.destination);

                visualizerCanvas = document.getElementById('visualizerCanvas');
                visualizerContext = visualizerCanvas.getContext('2d');
                resizeCanvas();
                visualize();
                setupMIDI();
                if (synthesiaToggle.checked) createSynthesiaGrid();
            }
            
            function getCurrentSynthParams() {
                return {
                    osc1: {
                        waveform: waveformOsc1Select.value,
                        detune: parseFloat(detuneOsc1Input.value),
                        level: parseFloat(levelOsc1Input.value),
                        pulseWidth: waveformOsc1Select.value === 'pulse' ? parseFloat(pulseWidthInput.value) : 0.5,
                    },
                    osc2: {
                        enabled: enableOsc2Toggle.checked,
                        waveform: waveformOsc2Select.value,
                        octaveOffset: parseInt(octaveOsc2Select.value),
                        fineTune: parseFloat(fineTuneOsc2Input.value),
                        delay: parseFloat(delayOsc2Input.value),
                        level: parseFloat(levelOsc2Input.value),
                        pulseWidth: waveformOsc2Select.value === 'pulse' ? parseFloat(pulseWidthInput.value) : 0.5,
                    },
                    sub: {
                        enabled: enableSubToggle.checked,
                        waveform: waveformSubSelect.value,
                        octave: parseInt(octaveSubSelect.value),
                        level: parseFloat(levelSubInput.value)
                    },
                    noise: {
                        enabled: enableNoiseToggle.checked,
                        type: noiseTypeSelect.value,
                        level: parseFloat(levelNoiseInput.value)
                    },
                    common: {
                        oscSlop: parseFloat(oscSlopInput.value),
                    },
                    adsr: {
                        enabled: enableAdsrToggle.checked,
                        attack: parseFloat(attackInput.value),
                        decay: parseFloat(decayInput.value),
                        sustain: parseFloat(sustainInput.value),
                        release: parseFloat(releaseInput.value)
                    },
                    filter: {
                        enabled: enableFilterToggle.checked,
                        type: filterTypeSelect.value,
                        cutoff: parseFloat(filterCutoffInput.value),
                        resonance: parseFloat(filterResonanceInput.value)
                    }
                };
            }


            function createKeyboard() { keyboardContainer.innerHTML = ''; let computerKeyIndex = 0; let whiteKeyCounter = 0; const baseOctave = parseInt(octaveOsc1Select.value); const numOctaves = parseInt(numOctavesSelect.value); const totalWhiteKeys = WHITE_KEYS_PER_OCTAVE * numOctaves; for (let o = 0; o < numOctaves; ++o) { keysPattern.forEach((keyData, patternIndex) => { const currentOctave = baseOctave + o; const noteWithOctave = `${keyData.note}${currentOctave}`; const midiValue = (currentOctave * 12) + patternIndex; const keyElement = document.createElement('div'); keyElement.dataset.note = noteWithOctave; keyElement.dataset.midi = midiValue; keyElement.dataset.keymapIndex = computerKeyIndex; keyElement.dataset.isBlack = keyData.type === 'black'; if (keyData.type === 'white') { keyElement.className = 'white-key'; keyElement.style.flexBasis = `calc(100% / ${totalWhiteKeys})`; if (keyReverseLookup[computerKeyIndex] && o < 2) { const keyLabel = document.createElement('div'); keyLabel.className = 'key-label'; keyLabel.textContent = keyReverseLookup[computerKeyIndex].toUpperCase(); keyElement.appendChild(keyLabel); } keyboardContainer.appendChild(keyElement); whiteKeyCounter++; } else { keyElement.className = 'black-key'; const whiteKeyRelativeWidth = (100 / totalWhiteKeys); keyElement.style.left = `${(whiteKeyCounter - 1) * whiteKeyRelativeWidth + (whiteKeyRelativeWidth * 0.65)}%`; keyElement.style.width = `${whiteKeyRelativeWidth * 0.6}%`; if (keyReverseLookup[computerKeyIndex] && o < 2) { const keyLabel = document.createElement('div'); keyLabel.className = 'key-label'; keyLabel.textContent = keyReverseLookup[computerKeyIndex].toUpperCase(); keyElement.appendChild(keyLabel); } keyboardContainer.appendChild(keyElement); } computerKeyIndex++; }); } }
            function noteToFrequency(note, octaveOffset = 0){const nN=note.replace(/\d+$/,'');const bO=parseInt(note.match(/\d+$/)[0]);const tO=bO+octaveOffset;const nI=midiNoteNames.indexOf(nN);const cA4M=69;const cMN=(tO*12)+nI;return 440*Math.pow(2,(cMN-cA4M)/12);}
            function midiNoteToNoteString(mN){const o=Math.floor(mN/12),nI=mN%12;return midiNoteNames[nI]+o;}
            function getPulseShaperCurve(width) {const c=new Float32Array(256);const t=width*2-1;for(let i=0;i<256;i++){const x=(i/255)*2-1;c[i]=x<t?-1:1;}return c;}

            function playNote(noteString, velocity = 0.7, source = "unknown", forceRetrigger = false, synthParamsOverride = null) {
                if (!audioContext) initAudio();
                if (!audioContext) { console.warn("Audio context not available for playNote."); return null; }

                const params = synthParamsOverride || getCurrentSynthParams();
                const slotId = source.startsWith('looper-slot-') ? parseInt(source.split('-')[2]) : -1;

                if (slotId === -1 && currentArmedSlotId !== -1 && loopSlotsData[currentArmedSlotId].isRecording) {
                    recordEvent(currentArmedSlotId, 'noteon', noteString, velocity, params);
                }
                
                const now = audioContext.currentTime;

                if (slotId === -1) { 
                    if (activeSoundUnits[noteString] && !forceRetrigger) { 
                        if (sustainPedalActive) notesSustained.add(noteString); 
                        return null; 
                    }
                    if (activeSoundUnits[noteString] && forceRetrigger) { 
                        const oU = activeSoundUnits[noteString]; 
                        oU.mainNoteGain.gain.cancelScheduledValues(now); 
                        let cOGV=0; try{cOGV=oU.mainNoteGain.gain.value;}catch(e){} 
                        oU.mainNoteGain.gain.setValueAtTime(Math.max(cOGV,0.00001),now); 
                        oU.mainNoteGain.gain.exponentialRampToValueAtTime(0.0001,now+0.02); 
                        const qST=now+0.02+0.05; 
                        oU.oscillators.forEach(o=>{try{o.stop(qST);}catch(e){}}); 
                        if(oU.noiseOsc)try{oU.noiseOsc.stop(qST);}catch(e){} 
                        setTimeout(()=>{
                            if(oU.mainNoteGain)oU.mainNoteGain.disconnect(); 
                            if(oU.gain1 && summingGainOsc1 && oU.gain1.numberOfOutputs > 0) oU.gain1.disconnect(summingGainOsc1); 
                            if(oU.gain2 && summingGainOsc2 && oU.gain2.numberOfOutputs > 0) oU.gain2.disconnect(summingGainOsc2);
                        }, (0.02+0.05+0.01)*1000); 
                        delete activeSoundUnits[noteString];
                    }
                }

                const unit = { mainNoteGain: audioContext.createGain(), oscillators: [], source: source };
                
                if (slotId !== -1) { 
                    if (!loopSlotsData[slotId].soundUnits[noteString]) {
                        loopSlotsData[slotId].soundUnits[noteString] = [];
                    }
                    loopSlotsData[slotId].soundUnits[noteString].push(unit);
                } else { 
                    activeSoundUnits[noteString] = unit;
                }


                if (params.adsr.enabled) {
                    const atk = params.adsr.attack; const dcy = params.adsr.decay; const sus = params.adsr.sustain * velocity;
                    unit.mainNoteGain.gain.setValueAtTime(0, now); unit.mainNoteGain.gain.linearRampToValueAtTime(velocity, now + atk); unit.mainNoteGain.gain.linearRampToValueAtTime(sus, now + atk + dcy);
                } else { 
                    unit.mainNoteGain.gain.setValueAtTime(0, now);
                    unit.mainNoteGain.gain.linearRampToValueAtTime(velocity, now + 0.001); 
                }

                if (params.filter.enabled) {
                    unit.mainNoteGain.connect(filterNode);
                    if (!synthParamsOverride || slotId === -1) { 
                         filterNode.type = params.filter.type;
                         filterNode.frequency.setTargetAtTime(params.filter.cutoff, now, 0.01);
                         filterNode.Q.setTargetAtTime(params.filter.resonance, now, 0.01);
                    } else { 
                         filterNode.type = params.filter.type;
                         filterNode.frequency.setValueAtTime(params.filter.cutoff, now); 
                         filterNode.Q.setValueAtTime(params.filter.resonance, now);
                    }
                } else {
                    unit.mainNoteGain.connect(filterBypassGain);
                }


                const slopVal = params.common.oscSlop * 100;

                const baseFreq1 = noteToFrequency(noteString, 0);
                const detune1Cents = params.osc1.detune;
                const slop1 = (Math.random() * 2 - 1) * slopVal;
                const freq1 = baseFreq1 * Math.pow(2, (detune1Cents + slop1) / 1200);
                unit.osc1 = audioContext.createOscillator();
                unit.osc1.type = params.osc1.waveform === 'pulse' ? 'sawtooth' : params.osc1.waveform;
                unit.osc1.frequency.setValueAtTime(freq1, now);
                unit.gain1 = audioContext.createGain(); unit.gain1.gain.value = params.osc1.level;
                if (params.osc1.waveform === 'pulse') { unit.shaper1 = audioContext.createWaveShaper(); unit.shaper1.curve = getPulseShaperCurve(params.osc1.pulseWidth); unit.osc1.connect(unit.shaper1).connect(unit.gain1);} else { unit.osc1.connect(unit.gain1);}
                unit.gain1.connect(unit.mainNoteGain);
                if (summingGainOsc1 && slotId === -1) unit.gain1.connect(summingGainOsc1); 
                unit.osc1.start(now); unit.oscillators.push(unit.osc1);

                if (params.osc2.enabled && params.osc2.level > 0) {
                    const octOffset2 = params.osc2.octaveOffset; const fineTune2 = params.osc2.fineTune;
                    const freq2Base = noteToFrequency(noteString, octOffset2);
                    const slop2 = (Math.random() * 2 - 1) * slopVal;
                    const freq2 = freq2Base * Math.pow(2, (fineTune2 + slop2) / 1200);
                    const startDelay2Ms = params.osc2.delay;

                    unit.osc2 = audioContext.createOscillator(); unit.osc2.type = params.osc2.waveform === 'pulse' ? 'sawtooth' : params.osc2.waveform;
                    unit.osc2.frequency.setValueAtTime(freq2, now);
                    unit.gain2 = audioContext.createGain(); unit.gain2.gain.value = params.osc2.level;
                    if (params.osc2.waveform === 'pulse') { unit.shaper2 = audioContext.createWaveShaper(); unit.shaper2.curve = getPulseShaperCurve(params.osc2.pulseWidth); unit.osc2.connect(unit.shaper2).connect(unit.gain2); } else { unit.osc2.connect(unit.gain2); }
                    unit.gain2.connect(unit.mainNoteGain);
                    if (summingGainOsc2 && slotId === -1) unit.gain2.connect(summingGainOsc2); 
                    unit.osc2.start(now + startDelay2Ms / 1000); unit.oscillators.push(unit.osc2);
                }
                if (params.sub.enabled && params.sub.level > 0) { 
                    const sOO = params.sub.octave; const fS = noteToFrequency(noteString, sOO); const sS = (Math.random()*2-1)*slopVal; 
                    unit.subOsc = audioContext.createOscillator(); unit.subOsc.type = params.sub.waveform; 
                    unit.subOsc.frequency.setValueAtTime(fS * Math.pow(2, sS/1200), now); 
                    unit.subGain = audioContext.createGain(); unit.subGain.gain.value = params.sub.level; 
                    unit.subOsc.connect(unit.subGain).connect(unit.mainNoteGain); 
                    unit.subOsc.start(now); unit.oscillators.push(unit.subOsc);
                }
                if (params.noise.enabled && params.noise.level > 0 && whiteNoiseBuffer) { 
                    unit.noiseOsc = audioContext.createBufferSource(); unit.noiseOsc.buffer = whiteNoiseBuffer; unit.noiseOsc.loop = true; 
                    unit.noiseGain = audioContext.createGain(); unit.noiseGain.gain.value = params.noise.level; 
                    if (params.noise.type === 'pink') { 
                        unit.noiseFilter = audioContext.createBiquadFilter(); unit.noiseFilter.type = 'lowpass'; 
                        unit.noiseFilter.frequency.setValueAtTime(1500, now); unit.noiseFilter.Q.setValueAtTime(0.707, now); 
                        unit.noiseOsc.connect(unit.noiseFilter).connect(unit.noiseGain);
                    } else { unit.noiseOsc.connect(unit.noiseGain); } 
                    unit.noiseGain.connect(unit.mainNoteGain); unit.noiseOsc.start(now); unit.oscillators.push(unit.noiseOsc);
                }

                if (slotId !== -1) {
                    loopSlotsData[slotId].notesCurrentlyPlaying.add(noteString);
                } else { 
                    if (sustainPedalActive) notesSustained.add(noteString);
                    cycleLEDs(); 
                    if (synthesiaToggle.checked) startFallingNote(noteString);
                }
                return unit;
            }

            function stopNote(noteString, source = "unknown", synthParamsOverride = null) {
                const params = synthParamsOverride || getCurrentSynthParams();
                const slotId = source.startsWith('looper-slot-') ? parseInt(source.split('-')[2]) : -1;

                if (slotId === -1 && currentArmedSlotId !== -1 && loopSlotsData[currentArmedSlotId].isRecording) {
                     recordEvent(currentArmedSlotId, 'noteoff', noteString, 0, null);
                }

                if (slotId === -1) { 
                    if (sustainPedalActive && source!=='sustain_release' && source!=='emergency' && source!=='octave_change' && source!=='num_octaves_change') {
                        notesSustained.add(noteString);
                         if (source==="computer" || source==="touch-end" || source==="mouse-drag-end") { const kEl=keyboardContainer.querySelector(`[data-note="${noteString}"]`); if(kEl)kEl.classList.remove('active'); if(source==="computer")activeComputerKeys.delete(noteString);}
                        if(synthesiaToggle.checked) releaseFallingNote(noteString);
                        return;
                    }
                    if (!audioContext || !activeSoundUnits[noteString]) return;
                } else { 
                    if (!audioContext || !loopSlotsData[slotId] || !loopSlotsData[slotId].soundUnits[noteString] || loopSlotsData[slotId].soundUnits[noteString].length === 0) return;
                }

                const unit = (slotId !== -1) 
                    ? loopSlotsData[slotId].soundUnits[noteString].shift() 
                    : activeSoundUnits[noteString];

                if (!unit) return; 

                const now = audioContext.currentTime; 
                let relTime;

                if (params.adsr.enabled) {
                    relTime = params.adsr.release;
                    let cGV = 0; try {cGV = unit.mainNoteGain.gain.value;}catch(e){}
                    unit.mainNoteGain.gain.cancelScheduledValues(now); unit.mainNoteGain.gain.setValueAtTime(Math.max(cGV,0.00001),now); unit.mainNoteGain.gain.exponentialRampToValueAtTime(0.0001, now + relTime);
                } else { 
                    relTime = 0.001; 
                    let cGV = 0; try {cGV = unit.mainNoteGain.gain.value;}catch(e){}
                    unit.mainNoteGain.gain.cancelScheduledValues(now); unit.mainNoteGain.gain.setValueAtTime(Math.max(cGV,0.00001),now);
                    unit.mainNoteGain.gain.exponentialRampToValueAtTime(0.0001, now + relTime);
                }

                const sT = now + relTime + 0.05;
                unit.oscillators.forEach(osc => { try { osc.stop(sT); } catch(e){} });
                
                setTimeout(() => {
                    if(unit.mainNoteGain) unit.mainNoteGain.disconnect();
                    if(unit.gain1) unit.gain1.disconnect(); 
                    if(unit.gain2) unit.gain2.disconnect(); 
                    if(unit.subGain) unit.subGain.disconnect(); 
                    if(unit.noiseGain) unit.noiseGain.disconnect(); 
                    if(unit.noiseFilter) unit.noiseFilter.disconnect(); 
                    if(unit.shaper1) unit.shaper1.disconnect(); 
                    if(unit.shaper2) unit.shaper2.disconnect();
                    
                    if (slotId === -1) { 
                        if(unit.gain1 && summingGainOsc1 && unit.gain1.numberOfOutputs > 0) { try { unit.gain1.disconnect(summingGainOsc1); } catch(e) {} }
                        if(unit.gain2 && summingGainOsc2 && unit.gain2.numberOfOutputs > 0) { try { unit.gain2.disconnect(summingGainOsc2); } catch(e) {} }
                    }
                }, (relTime + 0.15) * 1000);

                if (slotId === -1) { 
                    delete activeSoundUnits[noteString];
                    if (notesSustained.has(noteString) && source === 'sustain_release') notesSustained.delete(noteString);
                    if (synthesiaToggle.checked) releaseFallingNote(noteString);
                } else { 
                    loopSlotsData[slotId].notesCurrentlyPlaying.delete(noteString);
                }
            }

            function setupKeyboardEvents() { keyboardContainer.addEventListener('mousedown', e => { if (!audioContext) initAudio(); if (!audioContext || e.button !== 0) return; const tK = e.target.closest('.white-key, .black-key'); if (tK) { isMouseDraggingOnKeyboard = true; document.body.style.userSelect = 'none'; const n = tK.dataset.note; playNote(n, 0.7, "mouse-drag-start", true); tK.classList.add('active'); currentDraggedKeyElement = tK; } }); document.addEventListener('mousemove', e => { if (!isMouseDraggingOnKeyboard) return; const kUM = document.elementFromPoint(e.clientX, e.clientY)?.closest('.white-key, .black-key'); if (kUM && kUM !== currentDraggedKeyElement) { if (currentDraggedKeyElement) { stopNote(currentDraggedKeyElement.dataset.note, "mouse-drag-slide-out"); if (!sustainPedalActive) currentDraggedKeyElement.classList.remove('active'); } const n = kUM.dataset.note; playNote(n, 0.7, "mouse-drag-slide-in", true); kUM.classList.add('active'); currentDraggedKeyElement = kUM; } else if (!kUM && currentDraggedKeyElement) { stopNote(currentDraggedKeyElement.dataset.note, "mouse-drag-off-key"); if (!sustainPedalActive) currentDraggedKeyElement.classList.remove('active'); currentDraggedKeyElement = null; } }); document.addEventListener('mouseup', e => { if (e.button !== 0) return; if (isMouseDraggingOnKeyboard) { if (currentDraggedKeyElement) { stopNote(currentDraggedKeyElement.dataset.note, "mouse-drag-end"); if (!sustainPedalActive) currentDraggedKeyElement.classList.remove('active'); } isMouseDraggingOnKeyboard = false; document.body.style.userSelect = ''; currentDraggedKeyElement = null; } }); keyboardContainer.addEventListener('touchstart', e => { if (!audioContext) initAudio(); if (!audioContext) return; e.preventDefault(); for (let t of e.changedTouches) { const tK = document.elementFromPoint(t.clientX, t.clientY)?.closest('.white-key, .black-key'); if (tK) { const n = tK.dataset.note; playNote(n, 0.7, "touch-start", true); tK.classList.add('active'); activeTouches.set(t.identifier, tK); } } }, { passive: false }); keyboardContainer.addEventListener('touchmove', e => { if (!audioContext) return; e.preventDefault(); for (let t of e.changedTouches) { const tI = t.identifier; const kUT = document.elementFromPoint(t.clientX, t.clientY)?.closest('.white-key, .black-key'); const pKFT = activeTouches.get(tI); if (kUT !== pKFT) { if (pKFT) { stopNote(pKFT.dataset.note, "touch-slide-out"); if (!sustainPedalActive) pKFT.classList.remove('active'); } if (kUT) { const n = kUT.dataset.note; playNote(n, 0.7, "touch-slide-in", true); kUT.classList.add('active'); activeTouches.set(tI, kUT); } else { activeTouches.delete(tI); } } } }, { passive: false }); keyboardContainer.addEventListener('touchend', e => { e.preventDefault(); for (let t of e.changedTouches) { const tI = t.identifier; const rK = activeTouches.get(tI); if (rK) { stopNote(rK.dataset.note, "touch-end"); if (!sustainPedalActive) rK.classList.remove('active'); activeTouches.delete(tI); } } }, { passive: false }); keyboardContainer.addEventListener('touchcancel', e => { e.preventDefault(); for (let t of e.changedTouches) { const tI = t.identifier; const cK = activeTouches.get(tI); if (cK) { stopNote(cK.dataset.note, "touch-cancel"); if (!sustainPedalActive) cK.classList.remove('active'); activeTouches.delete(tI); } } }, { passive: false }); document.addEventListener('keydown', e => { if (e.target.closest('input, select, .std-button, .loop-slot-buttons button')) return; if (e.code === 'Space') { e.preventDefault(); if (!sustainPedalActive) { sustainPedalActive = true; activeComputerKeys.forEach(nS => playNote(nS, 0.7, "sustain_retrigger", false)); } } else if (!e.repeat && !e.metaKey && !e.ctrlKey && !e.altKey) { const k = e.key.toLowerCase(); if (!Object.prototype.hasOwnProperty.call(keyMapping, k)) return; const kI = keyMapping[k]; const kEl = keyboardContainer.querySelector(`[data-keymap-index="${kI}"]`); if (kEl && !activeComputerKeys.has(kEl.dataset.note)) { playNote(kEl.dataset.note, 0.7, "computer", true); kEl.classList.add('active'); activeComputerKeys.add(kEl.dataset.note); } } }); document.addEventListener('keyup', e => { if (e.target.closest('input, select, .std-button, .loop-slot-buttons button')) return; if (e.code === 'Space') { e.preventDefault(); if (sustainPedalActive) { sustainPedalActive = false; const nTR = new Set(notesSustained); nTR.forEach(nS => { if (!activeComputerKeys.has(nS) && !isKeyHeldByMouseOrTouch(nS)) { stopNote(nS, "sustain_release"); } }); notesSustained.clear(); } } else { const k = e.key.toLowerCase(); if (!Object.prototype.hasOwnProperty.call(keyMapping, k)) return; const kI = keyMapping[k]; const kEl = keyboardContainer.querySelector(`[data-keymap-index="${kI}"]`); if (kEl && activeComputerKeys.has(kEl.dataset.note)) { stopNote(kEl.dataset.note, "computer"); activeComputerKeys.delete(kEl.dataset.note); if (!sustainPedalActive) kEl.classList.remove('active'); } } }); }
            function isKeyHeldByMouseOrTouch(noteString) { if (currentDraggedKeyElement && currentDraggedKeyElement.dataset.note === noteString) return true; for (const kEl of activeTouches.values()) { if (kEl.dataset.note === noteString) return true; } return false; }
            function updatePulseWidthVisibility() { const o1P = waveformOsc1Select.value === 'pulse'; const o2P = (enableOsc2Toggle.checked && waveformOsc2Select.value === 'pulse'); if (o1P || o2P) { pulseWidthLabel.classList.remove('hidden-control'); } else { pulseWidthLabel.classList.add('hidden-control'); } }

            function setupControlEvents() {
                const sAPT = (p, v) => { if (audioContext && p) p.setTargetAtTime(parseFloat(v), audioContext.currentTime, 0.01);};
                waveformOsc1Select.addEventListener('change', updatePulseWidthVisibility);
                waveformOsc2Select.addEventListener('change', updatePulseWidthVisibility);
                levelOsc1Input.addEventListener('input', () => { const nL = parseFloat(levelOsc1Input.value); Object.values(activeSoundUnits).forEach(u => { if (u.gain1 && (!u.source || !u.source.startsWith('looper-slot-'))) sAPT(u.gain1.gain, nL); }); });
                levelOsc2Input.addEventListener('input', () => { const nL = parseFloat(levelOsc2Input.value); Object.values(activeSoundUnits).forEach(u => { if (u.gain2 && (!u.source || !u.source.startsWith('looper-slot-'))) sAPT(u.gain2.gain, nL); }); if (parseFloat(nL) == 0 && enableOsc2Toggle.checked) { enableOsc2Toggle.checked = false; toggleOsc2Controls(false); } else if (parseFloat(nL) > 0 && !enableOsc2Toggle.checked) { enableOsc2Toggle.checked = true; toggleOsc2Controls(true); } });
                pulseWidthInput.addEventListener('input', () => { const nW = parseFloat(pulseWidthInput.value); const nC = getPulseShaperCurve(nW); Object.values(activeSoundUnits).forEach(u => { if(!u.source || !u.source.startsWith('looper-slot-')) { if (u.shaper1) u.shaper1.curve = nC; if (u.shaper2) u.shaper2.curve = nC; } }); });
                levelSubInput.addEventListener('input', () => { const nL = parseFloat(levelSubInput.value); Object.values(activeSoundUnits).forEach(u => { if (u.subGain && (!u.source || !u.source.startsWith('looper-slot-'))) sAPT(u.subGain.gain, nL); }); if (parseFloat(nL) == 0 && enableSubToggle.checked) { enableSubToggle.checked = false; toggleSubControls(false); } else if (parseFloat(nL) > 0 && !enableSubToggle.checked) { enableSubToggle.checked = true; toggleSubControls(true); } });
                levelNoiseInput.addEventListener('input', () => { const nL = parseFloat(levelNoiseInput.value); Object.values(activeSoundUnits).forEach(u => { if (u.noiseGain && (!u.source || !u.source.startsWith('looper-slot-'))) sAPT(u.noiseGain.gain, nL); }); if (parseFloat(nL) == 0 && enableNoiseToggle.checked) { enableNoiseToggle.checked = false; toggleNoiseControls(false); } else if (parseFloat(nL) > 0 && !enableNoiseToggle.checked) { enableNoiseToggle.checked = true; toggleNoiseControls(true); } });

                octaveOsc1Select.addEventListener('change', () => { Object.keys(activeSoundUnits).forEach(n => stopNote(n, "octave_change")); createKeyboard(); });
                numOctavesSelect.addEventListener('change', () => { Object.keys(activeSoundUnits).forEach(n => stopNote(n, "num_octaves_change")); createKeyboard(); });

                filterTypeSelect.addEventListener('change', () => { if (filterNode && (!activeSoundUnits[Object.keys(activeSoundUnits)[0]]?.source?.startsWith('looper-slot-'))) filterNode.type = filterTypeSelect.value; }); 
                filterCutoffInput.addEventListener('input', () => { if (filterNode && (!activeSoundUnits[Object.keys(activeSoundUnits)[0]]?.source?.startsWith('looper-slot-'))) sAPT(filterNode.frequency, filterCutoffInput.value); });
                filterResonanceInput.addEventListener('input', () => { if (filterNode && (!activeSoundUnits[Object.keys(activeSoundUnits)[0]]?.source?.startsWith('looper-slot-'))) sAPT(filterNode.Q, filterResonanceInput.value); });

                masterVolumeInput.addEventListener('input', () => sAPT(masterGain?.gain, masterVolumeInput.value));
                uiThemeSelect.addEventListener('change', (e) => applyTheme(e.target.value));
                uiScaleInput.addEventListener('input', (e) => applyUIScale(parseFloat(e.target.value)));
                synthesiaToggle.addEventListener('change', (e) => { synthesiaContainer.classList.toggle('active', e.target.checked); localStorage.setItem('synthesiaEnabled', e.target.checked); if (e.target.checked) { if (audioContext) createSynthesiaGrid(); } else { clearSynthesiaGrid(); activeVisualNoteElements.forEach(d => { if (d.element && d.element.parentElement) d.element.remove(); }); activeVisualNoteElements = []; } });
                stopAllSoundsButton.addEventListener('click', emergencyStopAllSounds);

                enableOsc2Toggle.addEventListener('change', (e) => { toggleOsc2Controls(e.target.checked); updatePulseWidthVisibility(); });
                enableSubToggle.addEventListener('change', (e) => toggleSubControls(e.target.checked));
                enableNoiseToggle.addEventListener('change', (e) => toggleNoiseControls(e.target.checked));
                enableAdsrToggle.addEventListener('change', (e) => { adsrControls.style.display = e.target.checked ? '' : 'none'; });
                enableFilterToggle.addEventListener('change', (e) => { filterControlsElement.style.display = e.target.checked ? '' : 'none'; });

                toggleOsc2Controls(enableOsc2Toggle.checked);
                toggleSubControls(enableSubToggle.checked);
                toggleNoiseControls(enableNoiseToggle.checked);
                adsrControls.style.display = enableAdsrToggle.checked ? '' : 'none';
                filterControlsElement.style.display = enableFilterToggle.checked ? '' : 'none';

                toggleLooperButton.addEventListener('click', () => {
                    launchpadLooperContainer.classList.toggle('open');
                    toggleLooperButton.textContent = launchpadLooperContainer.classList.contains('open') ? 'Hide Looper' : 'Show Looper';
                });
            }

            function toggleOsc2Controls(enabled) { osc2ControlsWrapper.style.display = enabled ? '' : 'none'; if (!enabled && parseFloat(levelOsc2Input.value) > 0) { levelOsc2Input.value = 0; levelOsc2Input.dispatchEvent(new Event('input'));} else if (enabled && parseFloat(levelOsc2Input.value) === 0) {levelOsc2Input.value = 0.7; levelOsc2Input.dispatchEvent(new Event('input'));} }
            function toggleSubControls(enabled) { subOscControls.style.display = enabled ? '' : 'none'; if (!enabled && parseFloat(levelSubInput.value) > 0) {levelSubInput.value = 0;levelSubInput.dispatchEvent(new Event('input'));} else if (enabled && parseFloat(levelSubInput.value) === 0) {levelSubInput.value = 0.5;levelSubInput.dispatchEvent(new Event('input'));} }
            function toggleNoiseControls(enabled) { noiseControls.style.display = enabled ? '' : 'none'; if (!enabled && parseFloat(levelNoiseInput.value) > 0) {levelNoiseInput.value = 0;levelNoiseInput.dispatchEvent(new Event('input'));} else if (enabled && parseFloat(levelNoiseInput.value) === 0) {levelNoiseInput.value = 0.05;levelNoiseInput.dispatchEvent(new Event('input'));} }


            function emergencyStopAllSounds() {
                console.warn("PANIC: Stopping all sounds!"); 
                if(!audioContext)return; 
                const now = audioContext.currentTime; 
                
                Object.keys(activeSoundUnits).forEach(noteKey => { 
                    const unit = activeSoundUnits[noteKey]; 
                    if (unit.mainNoteGain) { 
                        unit.mainNoteGain.gain.cancelScheduledValues(now); 
                        unit.mainNoteGain.gain.setValueAtTime(Math.max(unit.mainNoteGain.gain.value, 0.0001), now); 
                        unit.mainNoteGain.gain.exponentialRampToValueAtTime(0.00001, now + 0.05);
                        setTimeout(() => {
                            if (unit.mainNoteGain.numberOfOutputs > 0) unit.mainNoteGain.disconnect();
                        }, 100); 
                    } 
                    unit.oscillators.forEach(osc => { try { osc.stop(now + 0.05); setTimeout(() => {if (osc.numberOfOutputs > 0) osc.disconnect();}, 100); } catch (e) {} }); 
                    delete activeSoundUnits[noteKey];
                });
                activeComputerKeys.clear(); activeTouches.clear(); 
                if(currentDraggedKeyElement){ currentDraggedKeyElement.classList.remove('active'); currentDraggedKeyElement=null;} 
                isMouseDraggingOnKeyboard=false; document.body.style.userSelect=''; 
                keyboardContainer.querySelectorAll('.active').forEach(e=>e.classList.remove('active')); 
                
                activeVisualNoteElements.forEach(d => { if(d.animationFrameId) cancelAnimationFrame(d.animationFrameId); if(d.element && d.element.parentElement) d.element.remove(); }); 
                activeVisualNoteElements = []; 
                sustainPedalActive = false; notesSustained.clear(); 
                
                if (looperQuantizationTimeout) clearTimeout(looperQuantizationTimeout);
                looperQuantizationTimeout = null;
                
                // For Panic, stop looper activity but DO NOT clear recorded data
                loopSlotsData.forEach((slot, slotId) => {
                    if (slot.isRecording) {
                        slot.isRecording = false;
                        // Update status but don't finalize loop duration as it's a panic
                        slot.statusText = slot.recordedEvents.length > 0 ? `Rec Aborted (${(slot.loopDuration / 1000).toFixed(1)}s)` : "Rec Aborted";
                    }
                    if (slot.isPlaying) {
                        stopPlaybackForSlot(slotId, true); // true for emergency stop, preserves data
                    }
                    // Status will be "Panic Stop" or "Rec Aborted" if it was playing/recording.
                    // If idle but has data, it remains. If empty, it's "Empty".
                    else if (!slot.isRecording && !slot.isPlaying && slot.recordedEvents.length > 0 && slot.loopDuration > 0){
                        slot.statusText = `Stopped (${(slot.loopDuration / 1000).toFixed(1)}s)`;
                    } else if (!slot.isRecording && !slot.isPlaying) {
                        slot.statusText = "Empty";
                    }
                });
                currentArmedSlotId = -1; 
                updateAllLoopSlotButtons(); // This will reflect the new statuses

                if (metronomeIntervalId) { clearInterval(metronomeIntervalId); metronomeIntervalId = null; } 
                metronomeEnabled = false; if(metronomeToggle) metronomeToggle.checked = false; if(metronomeLed) metronomeLed.classList.remove('active'); 
                console.log("All sounds and states (looper, metronome, sustain) reset. Looper data preserved."); 
            }

            function visualize() { requestAnimationFrame(visualize); if (!audioContext || !visualizerContext || !visualizerCanvas) return; let currentAnalyser = analyser; if (visualizerSourceSelect && visualizerSourceSelect.value === 'osc1' && analyserOsc1) { currentAnalyser = analyserOsc1; } else if (visualizerSourceSelect && visualizerSourceSelect.value === 'osc2' && analyserOsc2) { currentAnalyser = analyserOsc2; } if (!currentAnalyser) return; const bL=currentAnalyser.frequencyBinCount;const dA=new Uint8Array(bL);currentAnalyser.getByteTimeDomainData(dA);visualizerContext.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--primary-surface-color').trim();visualizerContext.fillRect(0,0,visualizerCanvas.width,visualizerCanvas.height);visualizerContext.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();visualizerContext.lineWidth=0.5*parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--font-scale-factor'));const nVL=4;for(let i=1;i<nVL;i++){const x=(visualizerCanvas.width/nVL)*i;visualizerContext.beginPath();visualizerContext.moveTo(x,0);visualizerContext.lineTo(x,visualizerCanvas.height);visualizerContext.stroke();}const nHL=2;for(let i=1;i<=nHL;i++){const y1=visualizerCanvas.height*(0.5-0.25*i);const y2=visualizerCanvas.height*(0.5+0.25*i);visualizerContext.beginPath();visualizerContext.moveTo(0,y1);visualizerContext.lineTo(visualizerCanvas.width,y1);visualizerContext.stroke();visualizerContext.beginPath();visualizerContext.moveTo(0,y2);visualizerContext.lineTo(visualizerCanvas.width,y2);visualizerContext.stroke();}visualizerContext.lineWidth=2.5*parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--font-scale-factor'));const aC=getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();visualizerContext.strokeStyle=aC;visualizerContext.shadowBlur=10*parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--font-scale-factor'));visualizerContext.shadowColor=aC;visualizerContext.beginPath();const sW=visualizerCanvas.width*1.0/bL;let x=0;for(let i=0;i<bL;i++){const v=dA[i]/128.0;const y=v*visualizerCanvas.height/2;if(i===0)visualizerContext.moveTo(x,y);else visualizerContext.lineTo(x,y);x+=sW;}visualizerContext.lineTo(visualizerCanvas.width,visualizerCanvas.height/2);visualizerContext.stroke();visualizerContext.shadowBlur=0; }
            let activeLEDIndex=0;const genLeds=[document.getElementById('led1'),document.getElementById('led2'),document.getElementById('led3')]; function cycleLEDs(){genLeds.forEach(l=>l.classList.remove('active'));if(genLeds[activeLEDIndex])genLeds[activeLEDIndex].classList.add('active');activeLEDIndex=(activeLEDIndex+1)%genLeds.length;}
            function resizeCanvas() { if (visualizerCanvas) { visualizerCanvas.width = visualizerCanvas.clientWidth; visualizerCanvas.height = visualizerCanvas.clientHeight; if (audioContext && analyser) { const sR = audioContext.sampleRate; const bTM = (analyser.fftSize / 2 / sR * 1000).toFixed(0); const fBTM = (analyser.fftSize / sR * 1000).toFixed(0); const tAL = visualizerCanvas.parentElement.querySelector('.visualizer-time-axis').children; if (tAL[1]) tAL[1].textContent = `~${bTM}ms`; if (tAL[2]) tAL[2].textContent = `~${fBTM}ms`; } } if (synthesiaToggle && synthesiaToggle.checked && audioContext) createSynthesiaGrid(); }
            function setupMIDI(){ if(navigator.requestMIDIAccess)navigator.requestMIDIAccess({sysex:false}).then(onS,onF);else console.warn("No MIDI support.");} function onS(mA){const iN=mA.inputs.values();for(let n=iN.next();n&&!n.done;n=iN.next())n.value.onmidimessage=onM;} function onF(m){console.error(`Failed MIDI: ${m}`);}
            function onM(msg){ const[cmd,nN,vR]=msg.data; const nS=midiNoteToNoteString(nN); const vL=vR/127; const kE=keyboardContainer.querySelector(`[data-midi="${nN}"]`); if((cmd&0xF0)===0x90&&vR>0){ playNote(nS,vL,"midi",true); if(kE)kE.classList.add('active');}else if((cmd&0xF0)===0x80||((cmd&0xF0)===0x90&&vR===0)){ stopNote(nS,"midi"); if(kE && !sustainPedalActive)kE.classList.remove('active');}}
            function createSynthesiaGrid(){ clearSynthesiaGrid();const cH=synthesiaContainer.clientHeight;const cW=synthesiaContainer.clientWidth;const sc=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--font-scale-factor'));const nHL=Math.max(1, Math.floor(cH / (50 * sc)));for(let i=1;i<nHL;i++){const l=document.createElement('div');l.className='synthesia-grid-line horizontal';l.style.top=`${(cH/nHL)*i}px`;synthesiaContainer.appendChild(l);}const nVL=Math.max(1, Math.floor(cW/(100*sc)));for(let i=1;i<nVL;i++){const l=document.createElement('div');l.className='synthesia-grid-line vertical';l.style.left=`${(cW/nVL)*i}px`;synthesiaContainer.appendChild(l);}}
            function clearSynthesiaGrid(){ synthesiaContainer.querySelectorAll('.synthesia-grid-line').forEach(el=>el.remove());}
            
            function startFallingNote(noteString){ 
                if (!synthesiaToggle.checked || !audioContext) return; 
                const keyElement = keyboardContainer.querySelector(`[data-note="${noteString}"]`); 
                if (!keyElement) return; 
                const noteRect = keyElement.getBoundingClientRect(); 
                const keyboardRect = keyboardContainer.getBoundingClientRect(); 
                const fallingElement = document.createElement('div'); 
                fallingElement.classList.add('falling-note'); 
                fallingElement.classList.toggle('white', !JSON.parse(keyElement.dataset.isBlack)); 
                fallingElement.classList.toggle('black', JSON.parse(keyElement.dataset.isBlack)); 
                fallingElement.textContent = noteString.replace(/\d+$/,''); 
                const keyLeftRelativeToKeyboard = noteRect.left - keyboardRect.left; 
                fallingElement.style.left = `${keyLeftRelativeToKeyboard}px`; 
                fallingElement.style.width = `${noteRect.width}px`; 
                fallingElement.style.top = '0px'; 
                const initialHeight = MIN_FALLING_NOTE_HEIGHT * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--font-scale-factor')); 
                fallingElement.style.height = `${initialHeight}px`; 
                fallingElement.dataset.noteString = noteString; 
                fallingElement.dataset.startTime = performance.now().toString(); 
                fallingElement.dataset.isReleasing = "false"; 
                fallingElement.dataset.releaseStartTime = "0";
                fallingElement.dataset.hasHit = "false"; // For burst effect
                fallingElement.dataset.burstComplete = "false"; // For burst removal
                synthesiaContainer.appendChild(fallingElement); 
                const animationData = { element: fallingElement, animationFrameId: null }; 
                activeVisualNoteElements.push(animationData); 
                const animate = (timestamp) => { animateFallingNoteElement(animationData, timestamp); }; 
                animationData.animationFrameId = requestAnimationFrame(animate);
            }

            function animateFallingNoteElement(animationData, currentTime) { 
                const { element } = animationData; 
                if (!element || !element.parentElement) { 
                    activeVisualNoteElements = activeVisualNoteElements.filter(ad => ad !== animationData); 
                    return; 
                }
                if (element.dataset.burstComplete === "true") {
                    if (element.parentElement) element.remove();
                    activeVisualNoteElements = activeVisualNoteElements.filter(ad => ad !== animationData);
                    return;
                }

                const startTime = parseFloat(element.dataset.startTime); 
                const isReleasing = element.dataset.isReleasing === "true"; 
                const releaseStartTime = parseFloat(element.dataset.releaseStartTime); 
                const fontScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--font-scale-factor')); 
                const containerHeight = synthesiaContainer.clientHeight; 
                const hitLineEl = synthesiaContainer.querySelector('.synthesia-hit-line');
                const hitLineRect = hitLineEl ? hitLineEl.getBoundingClientRect() : null;
                const containerRect = synthesiaContainer.getBoundingClientRect();

                // Original Synthesia note grows towards the line
                let noteDurationEstimate = (enableAdsrToggle.checked ? (parseFloat(attackInput.value) + parseFloat(decayInput.value)) : 0.01) + 0.5; 
                const fallSpeed = Math.max(10, (containerHeight - (hitLineRect ? hitLineRect.height : 10 * fontScale)) / noteDurationEstimate); 
                
                // Burst detection (when bottom of growing note hits the line)
                if (hitLineRect && element.dataset.hasHit === "false" && !isReleasing) {
                    const noteRect = element.getBoundingClientRect();
                    if (noteRect.bottom >= hitLineRect.top && noteRect.top < containerRect.bottom ) { // Check if it visually touches/crosses
                        element.classList.add('burst');
                        element.dataset.hasHit = "true";
                        setTimeout(() => {
                            element.dataset.burstComplete = "true"; 
                        }, BURST_ANIMATION_DURATION);
                    }
                }

                if (element.classList.contains('burst')) {
                    // CSS handles animation. RAF continues for eventual removal.
                } else if (isReleasing) { 
                    const timeSinceReleaseStarted = currentTime - releaseStartTime; 
                    const releaseProgress = Math.min(timeSinceReleaseStarted / NOTE_TAIL_DURATION_MS_VISUAL, 1); 
                    const initialTop = 0; // Not really used as transform is applied
                    const fallDistance = initialTop + (timeSinceReleaseStarted / 1000) * fallSpeed * 1.5; 
                    element.style.transform = `translateY(${fallDistance}px)`; 
                    element.style.opacity = `${0.9 * (1 - releaseProgress * 0.7)}`; 
                } else { // Growing phase
                    const elapsedMs = currentTime - startTime; 
                    const currentHeight = Math.max(MIN_FALLING_NOTE_HEIGHT * fontScale, (elapsedMs / 1000) * fallSpeed * 0.5); 
                    element.style.height = `${currentHeight}px`; 
                    element.style.transform = 'translateY(0px)'; 
                }
                
                // Continue animation?
                if (element.dataset.burstComplete !== "true") {
                    const noteRectForBounds = element.getBoundingClientRect();
                    if (!isReleasing || (isReleasing && parseFloat(element.style.opacity) > 0.01 && noteRectForBounds.top < containerRect.bottom + 50)) {
                         animationData.animationFrameId = requestAnimationFrame(ts => animateFallingNoteElement(animationData, ts));
                    } else if (isReleasing) { // Finished release fall (and not bursting)
                         if (element.parentElement) element.remove();
                         activeVisualNoteElements = activeVisualNoteElements.filter(ad => ad !== animationData);
                    }
                }
            }
            function releaseFallingNote(noteString) { 
                if (!synthesiaToggle.checked) return; 
                const now = performance.now(); 
                activeVisualNoteElements.forEach(animationData => { 
                    const { element } = animationData; 
                    if (element && element.dataset.noteString === noteString && element.dataset.isReleasing === "false" && !element.classList.contains('burst')) { 
                        element.dataset.isReleasing = "true"; 
                        element.dataset.releaseStartTime = now.toString(); 
                        element.classList.add('releasing'); 
                    }
                });
            }

            function updateBPMDisplay() { if(bpmDisplay) bpmDisplay.textContent = currentBPM; }
            function playMetronomeClickSound() { if (!audioContext || !metronomeClickBuffer) return; const s=audioContext.createBufferSource(); s.buffer=metronomeClickBuffer; const g=audioContext.createGain(); g.gain.value=0.25; s.connect(g).connect(audioContext.destination); s.start(audioContext.currentTime);}
            function metronomeTick() { if (!metronomeEnabled || !metronomeLed) return; metronomeLed.classList.toggle('active'); playMetronomeClickSound(); setTimeout(() => { if(metronomeEnabled && metronomeLed) metronomeLed.classList.remove('active');}, 50); }
            function startMetronome() { if (!audioContext) initAudio(); if (!audioContext) { alert("Audio not ready."); if(metronomeToggle)metronomeToggle.checked=false; return; } if (metronomeIntervalId) clearInterval(metronomeIntervalId); const iMs=(60/currentBPM)*1000; metronomeIntervalId=setInterval(metronomeTick,iMs); if(metronomeLed)metronomeLed.classList.remove('active'); metronomeTick();}
            function stopMetronome() { if(metronomeIntervalId)clearInterval(metronomeIntervalId); metronomeIntervalId=null; if(metronomeLed)metronomeLed.classList.remove('active');}
            function toggleMetronome() { if(!metronomeToggle) return; metronomeEnabled = metronomeToggle.checked; if (metronomeEnabled) startMetronome(); else stopMetronome();}
            function adjustBPM(amount) { currentBPM=Math.max(MIN_BPM,Math.min(MAX_BPM,currentBPM+amount)); updateBPMDisplay(); if(metronomeEnabled){stopMetronome();startMetronome();}}
            function handleTapTempo() { if(!audioContext)initAudio(); if(!audioContext)return; const n=performance.now(); if(tapTempoLastTap&&(n-tapTempoLastTap>MAX_TAP_INTERVAL)){tapTempoTimes.length=0;} tapTempoTimes.push(n); tapTempoLastTap=n; if(tapTempoTimes.length>4)tapTempoTimes.shift(); if(tapTempoTimes.length>=2){let aI=0; for(let i=1;i<tapTempoTimes.length;i++){aI+=tapTempoTimes[i]-tapTempoTimes[i-1];} aI/=(tapTempoTimes.length-1); if(aI>0){currentBPM=Math.round(60000/aI);currentBPM=Math.max(MIN_BPM,Math.min(MAX_BPM,currentBPM)); updateBPMDisplay(); if(metronomeEnabled){stopMetronome();startMetronome();}}}}
            function getBeatDurationMs() { return (60 / currentBPM) * 1000; }
            function getTimeUntilNextBeatMs() { if (!metronomeEnabled || !audioContext || audioContext.state !== 'running') return 0; const bDS = 60/currentBPM; const cTIB = (audioContext.currentTime % bDS); return (bDS - cTIB) * 1000;}

            // --- Launchpad Looper Functions ---
            function initializeLoopSlots() {
                loopSlotsData = [];
                launchpadLooperContainer.innerHTML = ''; 
                for (let i = 0; i < NUM_LOOP_SLOTS; i++) {
                    loopSlotsData.push({
                        id: i, recordedEvents: [], loopDuration: 0, loopStartTime: 0, 
                        isRecording: false, isPlaying: false, playbackScheduledEvents: [],
                        notesCurrentlyPlaying: new Set(), soundUnits: {}, 
                        statusText: "Empty", quantizeStartTime: 0 
                    });
                    createLoopSlotUI(i);
                }
                updateAllLoopSlotButtons();
            }

            function createLoopSlotUI(slotId) {
                const slotData = loopSlotsData[slotId]; // Use slotData consistently
                const slotDiv = document.createElement('div');
                slotDiv.className = 'loop-slot';
                slotDiv.id = `loop-slot-${slotId}`;

                const title = document.createElement('div');
                title.className = 'loop-slot-title';
                title.textContent = `Slot ${slotId + 1}`;
                slotDiv.appendChild(title);
                
                const status = document.createElement('div');
                status.className = 'loop-slot-status'; // Added class for styling
                status.id = `loop-slot-status-${slotId}`;
                status.textContent = slotData.statusText;
                slotDiv.appendChild(status);

                const buttonsDiv = document.createElement('div');
                buttonsDiv.className = 'loop-slot-buttons';

                const armButton = document.createElement('button');
                armButton.id = `loop-slot-arm-${slotId}`;
                // Text content will be set by updateAllLoopSlotButtons
                armButton.classList.add('std-button');
                armButton.onclick = () => { // Refined onclick logic here for clarity
                    const currentSlot = loopSlotsData[slotId];
                    if (currentSlot.isRecording) { // If this slot is recording, action is to stop.
                        toggleRecordOnArmedSlot(); // Assumes currentArmedSlotId is this slotId
                    } else if (currentArmedSlotId === slotId && !currentSlot.isPlaying) { // If armed and not playing, action is to start/toggle record.
                        toggleRecordOnArmedSlot();
                    } else { // Otherwise, the action is to arm this slot.
                        armSlot(slotId);
                    }
                };
                buttonsDiv.appendChild(armButton);

                const playButton = document.createElement('button');
                playButton.id = `loop-slot-play-${slotId}`;
                playButton.textContent = 'Play';
                playButton.classList.add('std-button');
                playButton.onclick = () => togglePlaySlot(slotId);
                buttonsDiv.appendChild(playButton);

                const clearButton = document.createElement('button');
                clearButton.id = `loop-slot-clear-${slotId}`;
                clearButton.textContent = 'Clear';
                clearButton.classList.add('std-button');
                clearButton.onclick = () => clearSlot(slotId);
                buttonsDiv.appendChild(clearButton);
                
                slotDiv.appendChild(buttonsDiv);

                const ledsDiv = document.createElement('div');
                ledsDiv.className = 'loop-slot-leds';
                const armedLed = document.createElement('span');
                armedLed.className = 'led';
                armedLed.id = `loop-slot-armed-led-${slotId}`;
                armedLed.title = "Armed for Recording";
                ledsDiv.appendChild(armedLed);

                const recordLed = document.createElement('span');
                recordLed.className = 'led record-led'; 
                recordLed.id = `loop-slot-record-led-${slotId}`;
                recordLed.title = "Recording";
                ledsDiv.appendChild(recordLed);
                
                const playLed = document.createElement('span');
                playLed.className = 'led'; 
                playLed.id = `loop-slot-play-led-${slotId}`;
                playLed.title = "Playing";
                ledsDiv.appendChild(playLed);
                slotDiv.appendChild(ledsDiv);

                launchpadLooperContainer.appendChild(slotDiv);
            }

            function armSlot(slotIdToArm) {
                const slotToArmData = loopSlotsData[slotIdToArm];

                // If this slot is already recording, clicking its "Arm" button (now "Stop Rec") should stop it.
                // This case is handled by the armButton.onclick logic directly calling toggleRecordOnArmedSlot.
                // So, if slotToArmData.isRecording is true, this function shouldn't be called by its own arm button
                // unless it's to arm it *from another context* which should be disallowed.

                // If trying to arm an already armed slot (and it's not playing), toggle record.
                if (currentArmedSlotId === slotIdToArm && !slotToArmData.isPlaying && !slotToArmData.isRecording) {
                    toggleRecordOnArmedSlot();
                    return;
                }
                
                // If another slot is currently recording, don't allow arming a new one.
                if (currentArmedSlotId !== -1 && currentArmedSlotId !== slotIdToArm && loopSlotsData[currentArmedSlotId].isRecording) {
                    console.warn("Cannot arm a new slot while another is recording.");
                    // You could add a temporary status message to the clicked slot here
                    const tempStatusTarget = document.getElementById(`loop-slot-status-${slotIdToArm}`);
                    if(tempStatusTarget) {
                        const oldText = tempStatusTarget.textContent;
                        tempStatusTarget.textContent = "Other rec busy";
                        setTimeout(() => { if(tempStatusTarget.textContent === "Other rec busy") tempStatusTarget.textContent = oldText; }, 1500);
                    }
                    return;
                }

                // If the slot to arm is currently playing, it cannot be armed.
                if (slotToArmData.isPlaying) {
                    console.warn(`Slot ${slotIdToArm + 1} is playing. Cannot arm.`);
                     const tempStatusTarget = document.getElementById(`loop-slot-status-${slotIdToArm}`);
                    if(tempStatusTarget) {
                        const oldText = tempStatusTarget.textContent;
                        tempStatusTarget.textContent = "Slot playing";
                        setTimeout(() => { if(tempStatusTarget.textContent === "Slot playing") tempStatusTarget.textContent = oldText; }, 1500);
                    }
                    return;
                }

                // Disarm any previously armed slot IF it's not the one we're currently arming
                // AND if it's not currently recording (that case is handled above)
                if (currentArmedSlotId !== -1 && currentArmedSlotId !== slotIdToArm && !loopSlotsData[currentArmedSlotId].isRecording) {
                    // No specific action needed to "disarm" other than changing currentArmedSlotId
                }
                
                currentArmedSlotId = slotIdToArm;
                updateAllLoopSlotButtons();
            }


            function toggleRecordOnArmedSlot() {
                if (currentArmedSlotId === -1) {
                    // This case should ideally be handled by UI (e.g., disabling record button if no slot armed)
                    // or by arming a default slot if desired. For now, it's a guard.
                    console.warn("No slot armed for recording action.");
                    return;
                }
                if (!audioContext) initAudio();
                if (!audioContext) { alert("Audio not ready."); return; }

                const slot = loopSlotsData[currentArmedSlotId];
                if (slot.isPlaying) { 
                    console.warn(`Slot ${currentArmedSlotId + 1} is playing. Stop playback to record.`);
                    return;
                }

                if (looperQuantizationTimeout) { // Clear any pending quantization
                    clearTimeout(looperQuantizationTimeout);
                    looperQuantizationTimeout = null;
                }

                if (slot.isRecording) { // --- Stop recording ---
                    slot.isRecording = false;
                    let rawDuration = performance.now() - slot.loopStartTime;
                    if (slot.recordedEvents.length === 0) {
                        slot.loopDuration = 0;
                        slot.statusText = "Rec Empty";
                    } else {
                        if (metronomeEnabled) {
                            const beatMs = getBeatDurationMs();
                            slot.loopDuration = Math.max(beatMs, Math.round(rawDuration / beatMs) * beatMs);
                            slot.statusText = `Rec Q (${(slot.loopDuration / 1000).toFixed(1)}s)`;
                        } else {
                            slot.loopDuration = rawDuration;
                            slot.statusText = `Rec (${(slot.loopDuration / 1000).toFixed(1)}s)`;
                        }
                    }
                    // currentArmedSlotId remains the same, slot is now armed but not recording.
                } else { // --- Start recording ---
                    if (metronomeEnabled && audioContext.state === 'running') {
                        const delayMs = getTimeUntilNextBeatMs();
                        slot.statusText = "Wait Beat...";
                        updateAllLoopSlotButtons(); // Update status immediately
                        looperQuantizationTimeout = setTimeout(() => {
                            looperQuantizationTimeout = null;
                            startActualRecordingForSlot(currentArmedSlotId);
                        }, delayMs);
                    } else {
                        startActualRecordingForSlot(currentArmedSlotId);
                    }
                }
                updateAllLoopSlotButtons();
            }
            
            function startActualRecordingForSlot(slotId) {
                const slot = loopSlotsData[slotId];
                slot.recordedEvents = [];
                slot.loopDuration = 0;
                slot.soundUnits = {}; 
                slot.notesCurrentlyPlaying.clear(); 
                slot.loopStartTime = performance.now();
                slot.quantizeStartTime = audioContext.currentTime; 
                slot.isRecording = true;
                slot.statusText = "Recording...";
                updateAllLoopSlotButtons();
            }

            function recordEvent(slotId, type, note, velocity, synthParams) {
                const slot = loopSlotsData[slotId];
                if (!slot || !slot.isRecording) return;
                const time = performance.now() - slot.loopStartTime;
                const eventData = { type, note, velocity, time };
                if (type === 'noteon' && synthParams) {
                    eventData.synthParams = JSON.parse(JSON.stringify(synthParams)); 
                }
                slot.recordedEvents.push(eventData);
            }

            function togglePlaySlot(slotId) {
                if (!audioContext) initAudio();
                if (!audioContext) { alert("Audio not ready."); return; }

                const slot = loopSlotsData[slotId];
                if (slot.isRecording) return; 
                if (slot.recordedEvents.length === 0 || slot.loopDuration <= 0) { // Check loopDuration > 0
                    slot.statusText = "Loop Empty";
                    updateAllLoopSlotButtons();
                    setTimeout(() => { 
                        if(slot.statusText === "Loop Empty") slot.statusText = "Empty"; 
                        updateAllLoopSlotButtons();
                    }, 2000);
                    return;
                }

                if (looperQuantizationTimeout) { 
                    clearTimeout(looperQuantizationTimeout);
                    looperQuantizationTimeout = null;
                }

                if (slot.isPlaying) {
                    stopPlaybackForSlot(slotId);
                } else {
                    if (metronomeEnabled && audioContext.state === 'running') {
                        const delayMs = getTimeUntilNextBeatMs();
                        slot.statusText = "Wait Beat...";
                        updateAllLoopSlotButtons(); 
                        looperQuantizationTimeout = setTimeout(() => {
                            looperQuantizationTimeout = null;
                            startPlaybackForSlot(slotId);
                        }, delayMs);
                    } else {
                        startPlaybackForSlot(slotId);
                    }
                }
            }
            
            function startPlaybackForSlot(slotId) {
                const slot = loopSlotsData[slotId];
                slot.isPlaying = true;
                slot.statusText = `Playing (${(slot.loopDuration / 1000).toFixed(1)}s)`;
                slot.notesCurrentlyPlaying.clear();
                slot.soundUnits = {}; 
                
                let playbackStartAudioTime = audioContext.currentTime;
                if (metronomeEnabled && slot.quantizeStartTime > 0 && audioContext.state === 'running') {
                    const beatDurationSec = 60 / currentBPM;
                    const timeSinceOriginalQuantizedStart = playbackStartAudioTime - slot.quantizeStartTime;
                    const offsetIntoBeat = timeSinceOriginalQuantizedStart % beatDurationSec;
                    playbackStartAudioTime = playbackStartAudioTime - offsetIntoBeat + beatDurationSec;
                     if (playbackStartAudioTime <= audioContext.currentTime + 0.005) { 
                        playbackStartAudioTime = audioContext.currentTime + getTimeUntilNextBeatMs()/1000;
                     }
                }
                
                playbackLoopSlot(slotId, playbackStartAudioTime);
                updateAllLoopSlotButtons();
            }

            function stopPlaybackForSlot(slotId, emergency = false) {
                const slot = loopSlotsData[slotId];
                if (!slot.isPlaying && !emergency) return;

                slot.isPlaying = false;
                slot.playbackScheduledEvents.forEach(clearTimeout);
                slot.playbackScheduledEvents = [];
                
                const notesToStop = new Set(slot.notesCurrentlyPlaying);
                notesToStop.forEach(noteString => {
                    const noteOnEvent = slot.recordedEvents.find(ev => ev.type === 'noteon' && ev.note === noteString);
                    const paramsForStop = noteOnEvent ? noteOnEvent.synthParams : null;
                    
                    if (slot.soundUnits[noteString]) {
                        while(slot.soundUnits[noteString].length > 0) {
                           stopNote(noteString, `looper-slot-${slotId}`, paramsForStop); 
                        }
                    }
                });
                slot.notesCurrentlyPlaying.clear();
                // slot.soundUnits = {}; // Keep soundUnits if notes are just stopping with release; clear if emergency?
                                      // stopNote will handle removing its instance. If all done, it will be empty.

                if (!emergency) {
                     slot.statusText = slot.recordedEvents.length > 0 ? `Stopped (${(slot.loopDuration / 1000).toFixed(1)}s)` : "Empty";
                } else { // From Panic button
                     slot.statusText = slot.recordedEvents.length > 0 ? `Panic Stop (${(slot.loopDuration / 1000).toFixed(1)}s)`: "Panic Stop (Empty)";
                }
                updateAllLoopSlotButtons();
            }
            
            function playbackLoopSlot(slotId, loopCycleStartAudioTime) {
                const slot = loopSlotsData[slotId];
                if (!slot.isPlaying || slot.recordedEvents.length === 0 || slot.loopDuration <= 0) { // loopDuration must be > 0
                    if (slot.isPlaying) stopPlaybackForSlot(slotId);
                    return;
                }

                slot.playbackScheduledEvents = [];

                slot.recordedEvents.forEach(event => {
                    const eventTimeInLoopSec = event.time / 1000.0;
                    const scheduledAudioTime = loopCycleStartAudioTime + eventTimeInLoopSec;
                    const delayMs = Math.max(0, (scheduledAudioTime - audioContext.currentTime) * 1000);

                    let timeoutId;
                    if (event.type === 'noteon') {
                        timeoutId = setTimeout(() => {
                            if (slot.isPlaying) { 
                                playNote(event.note, event.velocity, `looper-slot-${slotId}`, true, event.synthParams);
                            }
                        }, delayMs);
                    } else if (event.type === 'noteoff') {
                        timeoutId = setTimeout(() => {
                            if (slot.isPlaying) { 
                                const noteOnEvent = slot.recordedEvents.find(ev => ev.type === 'noteon' && ev.note === event.note && ev.time < event.time); 
                                const paramsForStop = noteOnEvent ? noteOnEvent.synthParams : null;
                                stopNote(event.note, `looper-slot-${slotId}`, paramsForStop);
                            }
                        }, delayMs);
                    }
                    if (timeoutId) slot.playbackScheduledEvents.push(timeoutId);
                });

                const loopDurationSec = slot.loopDuration / 1000.0;
                const nextCycleStartAudioTime = loopCycleStartAudioTime + loopDurationSec;
                const repeatDelayMs = Math.max(0, (nextCycleStartAudioTime - audioContext.currentTime) * 1000);

                const repeatTimeoutId = setTimeout(() => {
                    if (slot.isPlaying) { 
                        playbackLoopSlot(slotId, nextCycleStartAudioTime);
                    }
                }, repeatDelayMs);
                slot.playbackScheduledEvents.push(repeatTimeoutId);
            }

            function clearSlot(slotId) {
                if (looperQuantizationTimeout) clearTimeout(looperQuantizationTimeout);
                looperQuantizationTimeout = null;

                const slot = loopSlotsData[slotId];
                if (slot.isRecording) { 
                    slot.isRecording = false; // Stop recording immediately
                }
                if (slot.isPlaying) {
                    stopPlaybackForSlot(slotId); // Stop playback
                }
                if (currentArmedSlotId === slotId) {
                    currentArmedSlotId = -1; 
                }
                slot.recordedEvents = [];
                slot.loopDuration = 0;
                slot.loopStartTime = 0;
                slot.quantizeStartTime = 0;
                slot.notesCurrentlyPlaying.clear();
                slot.soundUnits = {};
                slot.statusText = "Empty";
                updateAllLoopSlotButtons();
            }

            function updateAllLoopSlotButtons() {
                loopSlotsData.forEach((slot, i) => {
                    const armButton = document.getElementById(`loop-slot-arm-${i}`);
                    const playButton = document.getElementById(`loop-slot-play-${i}`);
                    const clearButton = document.getElementById(`loop-slot-clear-${i}`);
                    const statusDisplay = document.getElementById(`loop-slot-status-${i}`);
                    const armedLed = document.getElementById(`loop-slot-armed-led-${i}`);
                    const recordLed = document.getElementById(`loop-slot-record-led-${i}`);
                    const playLed = document.getElementById(`loop-slot-play-led-${i}`);

                    if (!armButton || !playButton || !clearButton || !statusDisplay || !armedLed || !recordLed || !playLed) return;
                    
                    statusDisplay.textContent = slot.statusText;

                    // Arm/Record/Stop Rec Button Logic
                    if (slot.isRecording) {
                        armButton.textContent = 'Stop Rec';
                        armButton.classList.add('recording');
                        armButton.classList.remove('armed');
                        armButton.disabled = false;
                    } else if (currentArmedSlotId === i) { // Armed but not recording
                        armButton.textContent = 'Record';
                        armButton.classList.add('armed');
                        armButton.classList.remove('recording');
                        armButton.disabled = slot.isPlaying; // Can't record if playing
                    } else { // Not armed, not recording
                        armButton.textContent = 'Arm';
                        armButton.classList.remove('armed', 'recording');
                        // Disable arming if another slot is currently recording
                        const anotherSlotIsRecording = loopSlotsData.some(s => s.id !== i && s.isRecording);
                        armButton.disabled = anotherSlotIsRecording || slot.isPlaying;
                    }
                    
                    armedLed.classList.toggle('active', currentArmedSlotId === i && !slot.isRecording);
                    recordLed.classList.toggle('active', slot.isRecording); 
                    playLed.classList.toggle('active', slot.isPlaying);


                    playButton.textContent = slot.isPlaying ? 'Stop' : 'Play';
                    playButton.disabled = slot.isRecording || (slot.recordedEvents.length === 0 && !slot.isPlaying);
                    playButton.classList.toggle('playing', slot.isPlaying);
                    
                    clearButton.disabled = slot.isRecording || slot.isPlaying;
                });
            }


            window.addEventListener('load', () => {
                waveformOsc1Select = document.getElementById('waveformOsc1'); octaveOsc1Select = document.getElementById('octaveOsc1'); detuneOsc1Input = document.getElementById('detuneOsc1'); levelOsc1Input = document.getElementById('levelOsc1');
                enableOsc2Toggle = document.getElementById('enableOsc2'); waveformOsc2Select = document.getElementById('waveformOsc2'); octaveOsc2Select = document.getElementById('octaveOsc2'); fineTuneOsc2Input = document.getElementById('fineTuneOsc2'); delayOsc2Input = document.getElementById('delayOsc2'); levelOsc2Input = document.getElementById('levelOsc2'); osc2ControlsWrapper = document.getElementById('osc2-controls-wrapper');
                enableSubToggle = document.getElementById('enableSub'); waveformSubSelect = document.getElementById('waveformSub'); octaveSubSelect = document.getElementById('octaveSub'); levelSubInput = document.getElementById('levelSub'); subOscControls = document.getElementById('sub-osc-controls');
                enableNoiseToggle = document.getElementById('enableNoise'); noiseTypeSelect = document.getElementById('noiseType'); levelNoiseInput = document.getElementById('levelNoise'); noiseControls = document.getElementById('noise-controls');
                pulseWidthLabel = document.getElementById('pulseWidthLabel'); pulseWidthInput = document.getElementById('pulseWidth'); oscSlopInput = document.getElementById('oscSlop');
                enableAdsrToggle = document.getElementById('enableAdsr'); attackInput = document.getElementById('attack'); decayInput = document.getElementById('decay'); sustainInput = document.getElementById('sustain'); releaseInput = document.getElementById('release'); adsrControls = document.getElementById('adsr-controls');
                enableFilterToggle = document.getElementById('enableFilter'); filterTypeSelect = document.getElementById('filterType'); filterCutoffInput = document.getElementById('filterCutoff'); filterResonanceInput = document.getElementById('filterResonance'); filterControlsElement = document.getElementById('filter-controls');
                masterVolumeInput = document.getElementById('masterVolume'); numOctavesSelect = document.getElementById('numOctavesSelect'); visualizerSourceSelect = document.getElementById('visualizerSourceSelect');
                keyboardContainer = document.getElementById('keyboard'); uiThemeSelect = document.getElementById('uiTheme'); uiScaleInput = document.getElementById('uiScale');
                synthesiaToggle = document.getElementById('synthesiaToggle'); synthesiaContainer = document.getElementById('synthesiaContainer'); stopAllSoundsButton = document.getElementById('stopAllSoundsButton');
                toggleLooperButton = document.getElementById('toggleLooperButton');
                
                launchpadLooperContainer = document.getElementById('launchpadLooperContainer');

                metronomeToggle = document.getElementById('metronomeToggle'); bpmDisplay = document.getElementById('bpmDisplay'); bpmIncrement = document.getElementById('bpmIncrement'); bpmDecrement = document.getElementById('bpmDecrement'); tapTempoButton = document.getElementById('tapTempoButton'); metronomeLed = document.getElementById('metronomeLed');

                const sT=localStorage.getItem('synthTheme')||'midnight-drive'; if(uiThemeSelect)uiThemeSelect.value=sT;applyTheme(sT);
                const sS=parseFloat(localStorage.getItem('synthUIScale'))||100; if(uiScaleInput)uiScaleInput.value=sS;applyUIScale(sS);
                const sE=localStorage.getItem('synthesiaEnabled')==='true'; if(synthesiaToggle){synthesiaToggle.checked=sE; if(synthesiaContainer)synthesiaContainer.classList.toggle('active',sE);}

                initAudio();
                createKeyboard();
                setupKeyboardEvents();
                setupControlEvents(); // This now includes looper toggle listener
                updatePulseWidthVisibility();
                
                initializeLoopSlots(); 

                metronomeToggle.addEventListener('change', toggleMetronome); bpmIncrement.addEventListener('click', () => adjustBPM(1)); bpmDecrement.addEventListener('click', () => adjustBPM(-1)); tapTempoButton.addEventListener('click', handleTapTempo);
                updateBPMDisplay();

                window.addEventListener('resize',resizeCanvas);
                if(audioContext && audioContext.state === 'suspended') { const rA=()=>{if(audioContext&&audioContext.state==='suspended'){audioContext.resume().then(()=>{console.log("AudioContext resumed.");}).catch(e=>console.error("Error resuming AC:",e));}document.removeEventListener('click',rA);document.removeEventListener('keydown',rA);document.removeEventListener('touchstart',rA);};document.addEventListener('click',rA);document.addEventListener('keydown',rA);document.addEventListener('touchstart',rA);}
                if(sE && audioContext && synthesiaContainer && synthesiaContainer.classList.contains('active')) createSynthesiaGrid();
            });
        </script>

        <div style="position:fixed;bottom:10px;right:15px;font-family:'Poppins',Arial,sans-serif;font-size:calc(0.75em * var(--font-scale-factor));color:var(--text-muted-color);z-index:1001;display:flex;align-items:center;background-color:color-mix(in srgb, var(--primary-surface-color) 80%, transparent);padding:calc(5px * var(--font-scale-factor)) calc(10px * var(--font-scale-factor));border-radius:calc(6px * var(--font-scale-factor));box-shadow:0 2px 8px rgba(0,0,0,0.2);"> <svg style="scale:0.69" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="50px" height="50px"> <path fill="var(--text-muted-color)" d="M17.791,46.836C18.502,46.53,19,45.823,19,45v-5.4c0-0.197,0.016-0.402,0.041-0.61C19.027,38.994,19.014,38.997,19,39 c0,0-3,0-3.6,0c-1.5,0-2.8-0.6-3.4-1.8c-0.7-1.3-1-3.5-2.8-4.7C8.9,32.3,9.1,32,9.7,32c0.6,0.1,1.9,0.9,2.7,2c0.9,1.1,1.8,2,3.4,2 c2.487,0,3.82-0.125,4.622-0.555C21.356,34.056,22.649,33,24,33v-0.025c-5.668-0.182-9.289-2.066-10.975-4.975 c-3.665,0.042-6.856,0.405-8.677,0.707c-0.058-0.327-0.108-0.656-0.151-0.987c1.797-0.296,4.843-0.647,8.345-0.714 c-0.112-0.276-0.209-0.559-0.291-0.849c-3.511-0.178-6.541-0.039-8.187,0.097c-0.02-0.332-0.047-0.663-0.051-0.999 c1.649-0.135,4.597-0.27,8.018-0.111c-0.079-0.5-0.13-1.011-0.13-1.543c0-1.7,0.6-3.5,1.7-5c-0.5-1.7-1.2-5.3,0.2-6.6 c2.7,0,4.6,1.3,5.5,2.1C21,13.4,22.9,13,25,13s4,0.4,5.6,1.1c0.9-0.8,2.8-2.1,5.5-2.1c1.5,1.4,0.7,5,0.2,6.6c1.1,1.5,1.7,3.2,1.6,5 c0,0.484-0.045,0.951-0.11,1.409c3.499-0.172,6.527-0.034,8.204,0.102c-0.002,0.337-0.033,0.666-0.051,0.999 c-1.671-0.138-4.775-0.28-8.359-0.089c-0.089,0.336-0.197,0.663-0.325,0.98c3.546,0.046,6.665,0.389,8.548,0.689 c-0.043,0.332-0.093,0.661-0.151,0.987c-1.912-0.306-5.171-0.664-8.879-0.682C35.112,30.873,31.557,32.75,26,32.969V33 c2.6,0,5,3.9,5,6.6V45c0,0.823,0.498,1.53,1.209,1.836C41.37,43.804,48,35.164,48,25C48,12.318,37.683,2,25,2S2,12.318,2,25 C2,35.164,8.63,43.804,17.791,46.836z"/> </svg> <a href="https://github.com/jamubc" target="_blank" rel="noopener noreferrer" style="color: var(--text-muted-color); text-decoration: none; margin-right: calc(10px * var(--font-scale-factor));">jamubc</a> <span style="margin-right: calc(5px * var(--font-scale-factor));">|</span> <a href="https://github.com/shubin123" target="_blank" rel="noopener noreferrer" style="color: var(--text-muted-color); text-decoration: none;">shubin123</a> </div>
    </body>
</html>"